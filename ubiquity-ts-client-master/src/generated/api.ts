/* tslint:disable */
/* eslint-disable */
/**
 * Ubiquity REST API
 * Ubiquity provides a RESTful and uniform way to access blockchain resources, with a rich and reusable model across multiple cryptocurrencies.  [Documentation](https://app.blockdaemon.com/docs/ubiquity)  ### Protocols #### Mainnet The following protocols are currently supported: * bitcoin * ethereum * polkadot * xrp * algorand * stellar * dogecoin * oasis * near * terra * litecoin * bitcoincash * tezos  #### Testnet * bitcoin/testnet * ethereum/ropsten * dogecoin/testnet * litecoin/testnet * bitcoincash/testnet  #### Native Ubiquity provides native access to all Blockchain nodes it supports. * bitcoin/(mainnet | testnet) - [RPC Documentation](https://developer.bitcoin.org/reference/rpc/) * ethereum/(mainnet | ropsten) - [RPC Documentation](https://ethereum.org/en/developers/docs/apis/json-rpc/) * polkadot/mainnet - [Sidecar API Documentation](https://paritytech.github.io/substrate-api-sidecar/dist/) * polkadot/mainnet/http-rpc - [Polkadot RPC Documentation](https://polkadot.js.org/docs/substrate/rpc/) * algorand/mainnet - [Algod API Documentation](https://developer.algorand.org/docs/reference/rest-apis/algod/) * stellar/mainnet - [Stellar Horizon API Documentation](https://developers.stellar.org/api) * dogecoin/(mainnet | testnet) - [Dogecoin API Documentaion](https://developer.bitcoin.org/reference/rpc/) * oasis/mainnet - [Oasis Rosetta Gateway Documentation](https://www.rosetta-api.org/docs/api_identifiers.html#network-identifier) * near/mainnet - [NEAR RPC Documentation](https://docs.near.org/docs/api/rpc) * terra/mainnet - [Terra RPC Documentation](https://docs.terra.money/docs/develop/how-to/endpoints.html) * litecoin/mainnet - [Litecoin RPC Documentation](https://litecoin.info/index.php/Litecoin_API) * bitcoincash/mainnet - [Bitcoin Cash RPC Documentation](https://docs.bitcoincashnode.org/doc/json-rpc/) * tezos/mainnet - [Tezos RPC Documentation](https://tezos.gitlab.io/developer/rpc.html)   A full URL example: https://ubiquity.api.blockdaemon.com/v1/bitcoin/mainnet  ##### Pagination Certain resources contain a lot of data, more than what\'s practical to return for a single request. With the help of pagination, the data is split across multiple responses. Each response returns a subset of the items requested, and a continuation token.  To get the next batch of items, copy the returned continuation token to the continuation query parameter and repeat the request with the new URL. In case no continuation token is returned, there is no more data available. 
 *
 * The version of the OpenAPI document: 3.0.0
 * Contact: support@blockdaemon.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccountsObj
 */
export interface AccountsObj {
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountsObj
     */
    addresses?: Array<string>;
}
/**
 * 
 * @export
 * @interface AlgorandMeta
 */
export interface AlgorandMeta {
    /**
     * 
     * @type {string}
     * @memberof AlgorandMeta
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof AlgorandMeta
     */
    sender_reward?: string;
    /**
     * 
     * @type {string}
     * @memberof AlgorandMeta
     */
    recipient_reward?: string;
    /**
     * 
     * @type {string}
     * @memberof AlgorandMeta
     */
    close?: string;
    /**
     * 
     * @type {string}
     * @memberof AlgorandMeta
     */
    close_amount?: string;
    /**
     * 
     * @type {string}
     * @memberof AlgorandMeta
     */
    close_reward?: string;
}
/**
 * 
 * @export
 * @interface Asset
 */
export interface Asset {
    /**
     * 
     * @type {number}
     * @memberof Asset
     */
    token_id?: number;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    image_url?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    name?: string;
    /**
     * 
     * @type {Contract}
     * @memberof Asset
     */
    contract?: Contract;
    /**
     * 
     * @type {Array<AssetWallet>}
     * @memberof Asset
     */
    wallets?: Array<AssetWallet>;
    /**
     * 
     * @type {Array<AssetTrait>}
     * @memberof Asset
     */
    attributes?: Array<AssetTrait>;
    /**
     * 
     * @type {number}
     * @memberof Asset
     */
    mint_date?: number;
}
/**
 * 
 * @export
 * @interface AssetTrait
 */
export interface AssetTrait {
    /**
     * 
     * @type {string}
     * @memberof AssetTrait
     */
    trait_type?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetTrait
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface AssetWallet
 */
export interface AssetWallet {
    /**
     * 
     * @type {string}
     * @memberof AssetWallet
     */
    address?: string;
}
/**
 * Currency balances with asset paths as keys
 * @export
 * @interface Balance
 */
export interface Balance {
    /**
     * 
     * @type {Currency}
     * @memberof Balance
     */
    currency?: Currency;
    /**
     * 
     * @type {string}
     * @memberof Balance
     */
    confirmed_balance?: string;
    /**
     * 
     * @type {string}
     * @memberof Balance
     */
    pending_balance?: string;
    /**
     * 
     * @type {number}
     * @memberof Balance
     */
    confirmed_nonce?: number;
    /**
     * 
     * @type {number}
     * @memberof Balance
     */
    confirmed_block?: number;
}
/**
 * 
 * @export
 * @interface Block
 */
export interface Block {
    /**
     * Block number
     * @type {number}
     * @memberof Block
     */
    number?: number;
    /**
     * Block hash
     * @type {string}
     * @memberof Block
     */
    id?: string;
    /**
     * Parent block hash
     * @type {string}
     * @memberof Block
     */
    parent_id?: string;
    /**
     * Unix timestamp
     * @type {number}
     * @memberof Block
     */
    date?: number;
    /**
     * Amount of transaction in the block
     * @type {number}
     * @memberof Block
     */
    num_txs?: number;
    /**
     * Partial list of normalized transactions (not filtered or unknown model)
     * @type {Array<Tx>}
     * @memberof Block
     */
    txs?: Array<Tx>;
}
/**
 * 
 * @export
 * @interface BlockIdentifier
 */
export interface BlockIdentifier {
    /**
     * Block number
     * @type {number}
     * @memberof BlockIdentifier
     */
    number?: number;
    /**
     * Block hash
     * @type {string}
     * @memberof BlockIdentifier
     */
    id?: string;
    /**
     * Parent block hash
     * @type {string}
     * @memberof BlockIdentifier
     */
    parent_id?: string;
    /**
     * Unix timestamp
     * @type {number}
     * @memberof BlockIdentifier
     */
    date?: number;
}
/**
 * 
 * @export
 * @interface BlockIdentifierPage
 */
export interface BlockIdentifierPage {
    /**
     * Number of items in block identifiers
     * @type {number}
     * @memberof BlockIdentifierPage
     */
    total?: number;
    /**
     * 
     * @type {Array<BlockIdentifier>}
     * @memberof BlockIdentifierPage
     */
    items?: Array<BlockIdentifier>;
    /**
     * Token to get the next page
     * @type {number}
     * @memberof BlockIdentifierPage
     */
    continuation?: number | null;
}
/**
 * 
 * @export
 * @interface Collection
 */
export interface Collection {
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    image_url?: string;
    /**
     * 
     * @type {Array<Contract>}
     * @memberof Collection
     */
    contracts?: Array<Contract>;
    /**
     * 
     * @type {object}
     * @memberof Collection
     */
    meta?: object;
}
/**
 * 
 * @export
 * @interface Contract
 */
export interface Contract {
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    symbol?: string;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    image_url?: string;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    type?: string;
}
/**
 * @type Currency
 * @export
 */
export type Currency = NativeCurrency | SmartTokenCurrency | TokenCurrency;

/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {number}
     * @memberof Event
     */
    amount?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    block_id?: string;
    /**
     * 
     * @type {number}
     * @memberof Event
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof Event
     */
    date?: number;
    /**
     * 
     * @type {number}
     * @memberof Event
     */
    decimals?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    denomination?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    destination?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    id?: string;
    /**
     * 
     * @type {any}
     * @memberof Event
     */
    meta?: any | null;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    source?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    transaction_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface FeeEstimate
 */
export interface FeeEstimate {
    /**
     * Most recent block
     * @type {number}
     * @memberof FeeEstimate
     */
    most_recent_block?: number;
    /**
     * 
     * @type {FeeEstimateEstimatedFees}
     * @memberof FeeEstimate
     */
    estimated_fees?: FeeEstimateEstimatedFees;
}
/**
 * Object containing fast, medium, slow fees
 * @export
 * @interface FeeEstimateEstimatedFees
 */
export interface FeeEstimateEstimatedFees {
    /**
     * 
     * @type {any}
     * @memberof FeeEstimateEstimatedFees
     */
    fast?: any | null;
    /**
     * 
     * @type {any}
     * @memberof FeeEstimateEstimatedFees
     */
    medium?: any | null;
    /**
     * 
     * @type {any}
     * @memberof FeeEstimateEstimatedFees
     */
    slow?: any | null;
}
/**
 * 
 * @export
 * @interface GetCollectionResponse
 */
export interface GetCollectionResponse {
    /**
     * 
     * @type {Collection}
     * @memberof GetCollectionResponse
     */
    collection?: Collection;
}
/**
 * 
 * @export
 * @interface ListAssetsResponse
 */
export interface ListAssetsResponse {
    /**
     * 
     * @type {Array<Asset>}
     * @memberof ListAssetsResponse
     */
    data?: Array<Asset>;
    /**
     * 
     * @type {Meta}
     * @memberof ListAssetsResponse
     */
    meta?: Meta;
}
/**
 * 
 * @export
 * @interface ListCollectionResponse
 */
export interface ListCollectionResponse {
    /**
     * 
     * @type {Array<Collection>}
     * @memberof ListCollectionResponse
     */
    data?: Array<Collection>;
    /**
     * 
     * @type {Meta}
     * @memberof ListCollectionResponse
     */
    meta?: Meta;
}
/**
 * 
 * @export
 * @interface ListEventResponse
 */
export interface ListEventResponse {
    /**
     * 
     * @type {Array<NFTEvent>}
     * @memberof ListEventResponse
     */
    data?: Array<NFTEvent>;
    /**
     * 
     * @type {Meta}
     * @memberof ListEventResponse
     */
    meta?: Meta;
}
/**
 * 
 * @export
 * @interface Meta
 */
export interface Meta {
    /**
     * 
     * @type {Paging}
     * @memberof Meta
     */
    paging?: Paging;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * HTTP error type
     * @type {string}
     * @memberof ModelError
     */
    type?: string;
    /**
     * Numeric error code
     * @type {number}
     * @memberof ModelError
     */
    code?: number;
    /**
     * Short error description
     * @type {string}
     * @memberof ModelError
     */
    title?: string;
    /**
     * HTTP status of the error
     * @type {number}
     * @memberof ModelError
     */
    status?: number;
    /**
     * Long error description
     * @type {string}
     * @memberof ModelError
     */
    detail?: string;
}
/**
 * 
 * @export
 * @interface NFTEvent
 */
export interface NFTEvent {
    /**
     * 
     * @type {string}
     * @memberof NFTEvent
     */
    contract_address?: string;
    /**
     * 
     * @type {number}
     * @memberof NFTEvent
     */
    token_id?: number;
    /**
     * 
     * @type {string}
     * @memberof NFTEvent
     */
    event_type?: string;
    /**
     * 
     * @type {number}
     * @memberof NFTEvent
     */
    timestamp?: number;
    /**
     * 
     * @type {string}
     * @memberof NFTEvent
     */
    from_account?: string;
    /**
     * 
     * @type {string}
     * @memberof NFTEvent
     */
    to_account?: string;
    /**
     * 
     * @type {object}
     * @memberof NFTEvent
     */
    transaction?: object;
}
/**
 * 
 * @export
 * @interface NativeCurrency
 */
export interface NativeCurrency {
    /**
     * Asset path of transferred currency
     * @type {string}
     * @memberof NativeCurrency
     */
    asset_path: string;
    /**
     * Currency symbol
     * @type {string}
     * @memberof NativeCurrency
     */
    symbol?: string;
    /**
     * Name of currency
     * @type {string}
     * @memberof NativeCurrency
     */
    name?: string;
    /**
     * Decimal places right to the comma
     * @type {number}
     * @memberof NativeCurrency
     */
    decimals?: number;
    /**
     * 
     * @type {string}
     * @memberof NativeCurrency
     */
    type: string;
}
/**
 * 
 * @export
 * @interface Paging
 */
export interface Paging {
    /**
     * 
     * @type {string}
     * @memberof Paging
     */
    next_page_token?: string;
}
/**
 * 
 * @export
 * @interface PlatformDetail
 */
export interface PlatformDetail {
    /**
     * Backend API Type
     * @type {string}
     * @memberof PlatformDetail
     */
    source?: string;
    /**
     * 
     * @type {string}
     * @memberof PlatformDetail
     */
    handle?: string;
    /**
     * 
     * @type {number}
     * @memberof PlatformDetail
     */
    genesis_number?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlatformDetail
     */
    endpoints?: Array<string>;
}
/**
 * 
 * @export
 * @interface PlatformsOverview
 */
export interface PlatformsOverview {
    /**
     * List of items each describing a pair of supported platform and network.
     * @type {Array<PlatformsOverviewPlatforms>}
     * @memberof PlatformsOverview
     */
    platforms?: Array<PlatformsOverviewPlatforms>;
}
/**
 * 
 * @export
 * @interface PlatformsOverviewPlatforms
 */
export interface PlatformsOverviewPlatforms {
    /**
     * 
     * @type {string}
     * @memberof PlatformsOverviewPlatforms
     */
    handle?: string;
    /**
     * 
     * @type {string}
     * @memberof PlatformsOverviewPlatforms
     */
    network?: string;
}
/**
 * 
 * @export
 * @interface Report
 */
export interface Report {
    /**
     * Transaction items
     * @type {Array<ReportField>}
     * @memberof Report
     */
    fields: Array<ReportField>;
    /**
     * The number of transactions in the report
     * @type {number}
     * @memberof Report
     */
    items: number;
    /**
     * The limit number provided in the request or the default
     * @type {number}
     * @memberof Report
     */
    limit?: number;
    /**
     * Continuation token to send in the next request if there are more items
     * @type {string}
     * @memberof Report
     */
    continuation?: string;
}
/**
 * 
 * @export
 * @interface ReportField
 */
export interface ReportField {
    /**
     * The protocol the address relates to
     * @type {string}
     * @memberof ReportField
     */
    protocol: string;
    /**
     * The wallet/account the transaction occurred
     * @type {string}
     * @memberof ReportField
     */
    address: string;
    /**
     * The currency symbol
     * @type {string}
     * @memberof ReportField
     */
    currency: string;
    /**
     * The ID of the event within a transaction
     * @type {string}
     * @memberof ReportField
     */
    event_id: string;
    /**
     * The block number the transaction occurred on
     * @type {number}
     * @memberof ReportField
     */
    block: number;
    /**
     * The unix timestamp when the transaction was added to a block
     * @type {number}
     * @memberof ReportField
     */
    timestamp: number;
    /**
     * The transaction ID
     * @type {string}
     * @memberof ReportField
     */
    hash: string;
    /**
     * The action type e.g. Transfer, Deposit, Staking Reward etc..
     * @type {string}
     * @memberof ReportField
     */
    action: string;
    /**
     * The amount of currency involved in the transaction (smallest unit)
     * @type {string}
     * @memberof ReportField
     */
    value: string;
    /**
     * The address where the funds originated
     * @type {string}
     * @memberof ReportField
     */
    sender_address: string;
    /**
     * How much was charged as a fee for processing the transaction
     * @type {string}
     * @memberof ReportField
     */
    fee: string;
    /**
     * The number of decimals in one coin, used to convert smallest unit to 1 whole coin if needed
     * @type {number}
     * @memberof ReportField
     */
    decimals: number;
    /**
     * 
     * @type {ReportFieldMeta}
     * @memberof ReportField
     */
    meta?: ReportFieldMeta | null;
}
/**
 * @type ReportFieldMeta
 * Additional metadata bespoke to specific protocols
 * @export
 */
export type ReportFieldMeta = AlgorandMeta;

/**
 * 
 * @export
 * @interface SignedTx
 */
export interface SignedTx {
    /**
     * The signed TX
     * @type {string}
     * @memberof SignedTx
     */
    tx: string;
}
/**
 * 
 * @export
 * @interface SmartToken
 */
export interface SmartToken {
    /**
     * Name of token mechanism (smart contract)
     * @type {string}
     * @memberof SmartToken
     */
    type: string;
    /**
     * Address of contract
     * @type {string}
     * @memberof SmartToken
     */
    contract: string;
}
/**
 * 
 * @export
 * @interface SmartTokenCurrency
 */
export interface SmartTokenCurrency {
    /**
     * Asset path of transferred currency
     * @type {string}
     * @memberof SmartTokenCurrency
     */
    asset_path: string;
    /**
     * Currency symbol
     * @type {string}
     * @memberof SmartTokenCurrency
     */
    symbol?: string;
    /**
     * Name of currency
     * @type {string}
     * @memberof SmartTokenCurrency
     */
    name?: string;
    /**
     * Decimal places right to the comma
     * @type {number}
     * @memberof SmartTokenCurrency
     */
    decimals?: number;
    /**
     * 
     * @type {string}
     * @memberof SmartTokenCurrency
     */
    type: string;
    /**
     * 
     * @type {SmartToken}
     * @memberof SmartTokenCurrency
     */
    detail?: SmartToken;
}
/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * Name of token mechanism
     * @type {string}
     * @memberof Token
     */
    type: string;
    /**
     * Token identifier
     * @type {string}
     * @memberof Token
     */
    id: string;
    /**
     * Address that created token
     * @type {string}
     * @memberof Token
     */
    creator?: string;
}
/**
 * 
 * @export
 * @interface TokenCurrency
 */
export interface TokenCurrency {
    /**
     * Asset path of transferred currency
     * @type {string}
     * @memberof TokenCurrency
     */
    asset_path: string;
    /**
     * Currency symbol
     * @type {string}
     * @memberof TokenCurrency
     */
    symbol?: string;
    /**
     * Name of currency
     * @type {string}
     * @memberof TokenCurrency
     */
    name?: string;
    /**
     * Decimal places right to the comma
     * @type {number}
     * @memberof TokenCurrency
     */
    decimals?: number;
    /**
     * 
     * @type {string}
     * @memberof TokenCurrency
     */
    type: string;
    /**
     * 
     * @type {Token}
     * @memberof TokenCurrency
     */
    detail?: Token;
}
/**
 * 
 * @export
 * @interface Tx
 */
export interface Tx {
    /**
     * Unique transaction identifier
     * @type {string}
     * @memberof Tx
     */
    id?: string;
    /**
     * Unix timestamp
     * @type {number}
     * @memberof Tx
     */
    date?: number;
    /**
     * ID of block if mined, otherwise omitted.
     * @type {string}
     * @memberof Tx
     */
    block_id?: string | null;
    /**
     * Result status of the transaction.
     * @type {string}
     * @memberof Tx
     */
    status?: TxStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof Tx
     */
    nonce?: number;
    /**
     * 
     * @type {number}
     * @memberof Tx
     */
    num_events?: number;
    /**
     * 
     * @type {any}
     * @memberof Tx
     */
    meta?: any | null;
    /**
     * 
     * @type {Array<Event>}
     * @memberof Tx
     */
    events?: Array<Event> | null;
}

/**
    * @export
    * @enum {string}
    */
export enum TxStatusEnum {
    Completed = 'completed',
    Failed = 'failed'
}

/**
 * 
 * @export
 * @interface TxConfirmation
 */
export interface TxConfirmation {
    /**
     * Current Block Number
     * @type {number}
     * @memberof TxConfirmation
     */
    current_height?: number;
    /**
     * Transaction hash
     * @type {string}
     * @memberof TxConfirmation
     */
    tx_id?: string;
    /**
     * Total transaction confirmations
     * @type {number}
     * @memberof TxConfirmation
     */
    confirmations?: number;
}
/**
 * Transaction
 * @export
 * @interface TxMinify
 */
export interface TxMinify {
    /**
     * Unique transaction identifier
     * @type {string}
     * @memberof TxMinify
     */
    id?: string;
    /**
     * Unix timestamp
     * @type {number}
     * @memberof TxMinify
     */
    date?: number;
    /**
     * ID of block.
     * @type {string}
     * @memberof TxMinify
     */
    block_id?: string | null;
    /**
     * Height of block,
     * @type {number}
     * @memberof TxMinify
     */
    block_number?: number | null;
    /**
     * Total transaction confirmations
     * @type {number}
     * @memberof TxMinify
     */
    confirmations?: number;
}
/**
 * 
 * @export
 * @interface TxOutput
 */
export interface TxOutput {
    /**
     * Result status of the transaction output.
     * @type {string}
     * @memberof TxOutput
     */
    status?: TxOutputStatusEnum;
    /**
     * If the transaction output was spent or not, if the value is true the `spent` transaction object will be presented
     * @type {boolean}
     * @memberof TxOutput
     */
    is_spent?: boolean;
    /**
     * Amount of transaction output
     * @type {number}
     * @memberof TxOutput
     */
    value?: number | null;
    /**
     * 
     * @type {TxMinify}
     * @memberof TxOutput
     */
    mined?: TxMinify | null;
    /**
     * 
     * @type {TxMinify}
     * @memberof TxOutput
     */
    spent?: TxMinify | null;
}

/**
    * @export
    * @enum {string}
    */
export enum TxOutputStatusEnum {
    Mined = 'mined',
    Unknown = 'unknown'
}

/**
 * 
 * @export
 * @interface TxPage
 */
export interface TxPage {
    /**
     * Number of items in txs
     * @type {number}
     * @memberof TxPage
     */
    total?: number;
    /**
     * 
     * @type {Array<Tx>}
     * @memberof TxPage
     */
    items?: Array<Tx>;
    /**
     * Token to get the next page
     * @type {string}
     * @memberof TxPage
     */
    continuation?: string | null;
}
/**
 * 
 * @export
 * @interface TxReceipt
 */
export interface TxReceipt {
    /**
     * The transaction ID
     * @type {string}
     * @memberof TxReceipt
     */
    id: string;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the account balances for all supported currencies. 
         * @summary Balances Of Address
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfBalancesByAddress: async (platform: string, network: string, address: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getListOfBalancesByAddress', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getListOfBalancesByAddress', 'network', network)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getListOfBalancesByAddress', 'address', address)
            const localVarPath = `/{platform}/{network}/account/{address}`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the balances of accounts for all supported currencies. 
         * @summary Balances Of Addresses
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {AccountsObj} accountsObj 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfBalancesByAddresses: async (platform: string, network: string, accountsObj: AccountsObj, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getListOfBalancesByAddresses', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getListOfBalancesByAddresses', 'network', network)
            // verify required parameter 'accountsObj' is not null or undefined
            assertParamExists('getListOfBalancesByAddresses', 'accountsObj', accountsObj)
            const localVarPath = `/{platform}/{network}/accounts`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountsObj, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns account activity 
         * @summary A financial report for an address between a time period. Default timescale is within the last 30 days
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {number} [from] Unix Timestamp from where to start
         * @param {number} [to] Unix Timestamp from where to end
         * @param {number} [limit] Max number of items to return in a response. Defaults to 50k and is capped at 100k. 
         * @param {string} [continuation] Continuation token from earlier response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportByAddress: async (platform: string, network: string, address: string, from?: number, to?: number, limit?: number, continuation?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getReportByAddress', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getReportByAddress', 'network', network)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getReportByAddress', 'address', address)
            const localVarPath = `/{platform}/{network}/account/{address}/report`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (continuation !== undefined) {
                localVarQueryParameter['continuation'] = continuation;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets transactions that an address was involved with, from newest to oldest. This call uses pagination. 
         * @summary Transactions Of Address
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {'desc' | 'asc'} [order] Pagination order
         * @param {string} [continuation] Continuation token from earlier response
         * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100. 
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxsByAddress: async (platform: string, network: string, address: string, order?: 'desc' | 'asc', continuation?: string, limit?: number, assets?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getTxsByAddress', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getTxsByAddress', 'network', network)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getTxsByAddress', 'address', address)
            const localVarPath = `/{platform}/{network}/account/{address}/txs`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (continuation !== undefined) {
                localVarQueryParameter['continuation'] = continuation;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (assets !== undefined) {
                localVarQueryParameter['assets'] = assets;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the account balances for all supported currencies. 
         * @summary Balances Of Address
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListOfBalancesByAddress(platform: string, network: string, address: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Balance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListOfBalancesByAddress(platform, network, address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the balances of accounts for all supported currencies. 
         * @summary Balances Of Addresses
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {AccountsObj} accountsObj 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListOfBalancesByAddresses(platform: string, network: string, accountsObj: AccountsObj, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: Array<Balance>; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListOfBalancesByAddresses(platform, network, accountsObj, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns account activity 
         * @summary A financial report for an address between a time period. Default timescale is within the last 30 days
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {number} [from] Unix Timestamp from where to start
         * @param {number} [to] Unix Timestamp from where to end
         * @param {number} [limit] Max number of items to return in a response. Defaults to 50k and is capped at 100k. 
         * @param {string} [continuation] Continuation token from earlier response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReportByAddress(platform: string, network: string, address: string, from?: number, to?: number, limit?: number, continuation?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Report>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReportByAddress(platform, network, address, from, to, limit, continuation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets transactions that an address was involved with, from newest to oldest. This call uses pagination. 
         * @summary Transactions Of Address
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {'desc' | 'asc'} [order] Pagination order
         * @param {string} [continuation] Continuation token from earlier response
         * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100. 
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxsByAddress(platform: string, network: string, address: string, order?: 'desc' | 'asc', continuation?: string, limit?: number, assets?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTxsByAddress(platform, network, address, order, continuation, limit, assets, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Returns the account balances for all supported currencies. 
         * @summary Balances Of Address
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfBalancesByAddress(platform: string, network: string, address: string, options?: any): AxiosPromise<Array<Balance>> {
            return localVarFp.getListOfBalancesByAddress(platform, network, address, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the balances of accounts for all supported currencies. 
         * @summary Balances Of Addresses
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {AccountsObj} accountsObj 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfBalancesByAddresses(platform: string, network: string, accountsObj: AccountsObj, options?: any): AxiosPromise<{ [key: string]: Array<Balance>; }> {
            return localVarFp.getListOfBalancesByAddresses(platform, network, accountsObj, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns account activity 
         * @summary A financial report for an address between a time period. Default timescale is within the last 30 days
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {number} [from] Unix Timestamp from where to start
         * @param {number} [to] Unix Timestamp from where to end
         * @param {number} [limit] Max number of items to return in a response. Defaults to 50k and is capped at 100k. 
         * @param {string} [continuation] Continuation token from earlier response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportByAddress(platform: string, network: string, address: string, from?: number, to?: number, limit?: number, continuation?: string, options?: any): AxiosPromise<Report> {
            return localVarFp.getReportByAddress(platform, network, address, from, to, limit, continuation, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets transactions that an address was involved with, from newest to oldest. This call uses pagination. 
         * @summary Transactions Of Address
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {'desc' | 'asc'} [order] Pagination order
         * @param {string} [continuation] Continuation token from earlier response
         * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100. 
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxsByAddress(platform: string, network: string, address: string, order?: 'desc' | 'asc', continuation?: string, limit?: number, assets?: string, options?: any): AxiosPromise<TxPage> {
            return localVarFp.getTxsByAddress(platform, network, address, order, continuation, limit, assets, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Returns the account balances for all supported currencies. 
     * @summary Balances Of Address
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {string} address Account address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getListOfBalancesByAddress(platform: string, network: string, address: string, options?: any) {
        return AccountsApiFp(this.configuration).getListOfBalancesByAddress(platform, network, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the balances of accounts for all supported currencies. 
     * @summary Balances Of Addresses
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {AccountsObj} accountsObj 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getListOfBalancesByAddresses(platform: string, network: string, accountsObj: AccountsObj, options?: any) {
        return AccountsApiFp(this.configuration).getListOfBalancesByAddresses(platform, network, accountsObj, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns account activity 
     * @summary A financial report for an address between a time period. Default timescale is within the last 30 days
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {string} address Account address
     * @param {number} [from] Unix Timestamp from where to start
     * @param {number} [to] Unix Timestamp from where to end
     * @param {number} [limit] Max number of items to return in a response. Defaults to 50k and is capped at 100k. 
     * @param {string} [continuation] Continuation token from earlier response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getReportByAddress(platform: string, network: string, address: string, from?: number, to?: number, limit?: number, continuation?: string, options?: any) {
        return AccountsApiFp(this.configuration).getReportByAddress(platform, network, address, from, to, limit, continuation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets transactions that an address was involved with, from newest to oldest. This call uses pagination. 
     * @summary Transactions Of Address
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {string} address Account address
     * @param {'desc' | 'asc'} [order] Pagination order
     * @param {string} [continuation] Continuation token from earlier response
     * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100. 
     * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getTxsByAddress(platform: string, network: string, address: string, order?: 'desc' | 'asc', continuation?: string, limit?: number, assets?: string, options?: any) {
        return AccountsApiFp(this.configuration).getTxsByAddress(platform, network, address, order, continuation, limit, assets, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BlocksApi - axios parameter creator
 * @export
 */
export const BlocksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a block and all its transactions by the block number or hash
         * @summary Block By Number/Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} key Block number or block hash/ID or Special identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlock: async (platform: string, network: string, key: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getBlock', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getBlock', 'network', network)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getBlock', 'key', key)
            const localVarPath = `/{platform}/{network}/block/{key}`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get minimal block identifier by block number or hash
         * @summary Block Identifier By Number/Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} key Block number or block hash/ID or Special identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockIdentifier: async (platform: string, network: string, key: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getBlockIdentifier', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getBlockIdentifier', 'network', network)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getBlockIdentifier', 'key', key)
            const localVarPath = `/{platform}/{network}/block_identifier/{key}`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get minimal block identifiers from oldest to newest. This call uses pagination. 
         * @summary Block Identifiers
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockIdentifiers: async (platform: string, network: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getBlockIdentifiers', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getBlockIdentifiers', 'network', network)
            const localVarPath = `/{platform}/{network}/block_identifiers`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlocksApi - functional programming interface
 * @export
 */
export const BlocksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlocksApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a block and all its transactions by the block number or hash
         * @summary Block By Number/Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} key Block number or block hash/ID or Special identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlock(platform: string, network: string, key: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Block>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlock(platform, network, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get minimal block identifier by block number or hash
         * @summary Block Identifier By Number/Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} key Block number or block hash/ID or Special identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockIdentifier(platform: string, network: string, key: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlockIdentifier>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockIdentifier(platform, network, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get minimal block identifiers from oldest to newest. This call uses pagination. 
         * @summary Block Identifiers
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockIdentifiers(platform: string, network: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlockIdentifierPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockIdentifiers(platform, network, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BlocksApi - factory interface
 * @export
 */
export const BlocksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlocksApiFp(configuration)
    return {
        /**
         * Get a block and all its transactions by the block number or hash
         * @summary Block By Number/Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} key Block number or block hash/ID or Special identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlock(platform: string, network: string, key: string, options?: any): AxiosPromise<Block> {
            return localVarFp.getBlock(platform, network, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Get minimal block identifier by block number or hash
         * @summary Block Identifier By Number/Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} key Block number or block hash/ID or Special identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockIdentifier(platform: string, network: string, key: string, options?: any): AxiosPromise<BlockIdentifier> {
            return localVarFp.getBlockIdentifier(platform, network, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Get minimal block identifiers from oldest to newest. This call uses pagination. 
         * @summary Block Identifiers
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockIdentifiers(platform: string, network: string, options?: any): AxiosPromise<BlockIdentifierPage> {
            return localVarFp.getBlockIdentifiers(platform, network, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlocksApi - object-oriented interface
 * @export
 * @class BlocksApi
 * @extends {BaseAPI}
 */
export class BlocksApi extends BaseAPI {
    /**
     * Get a block and all its transactions by the block number or hash
     * @summary Block By Number/Hash
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {string} key Block number or block hash/ID or Special identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public getBlock(platform: string, network: string, key: string, options?: any) {
        return BlocksApiFp(this.configuration).getBlock(platform, network, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get minimal block identifier by block number or hash
     * @summary Block Identifier By Number/Hash
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {string} key Block number or block hash/ID or Special identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public getBlockIdentifier(platform: string, network: string, key: string, options?: any) {
        return BlocksApiFp(this.configuration).getBlockIdentifier(platform, network, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get minimal block identifiers from oldest to newest. This call uses pagination. 
     * @summary Block Identifiers
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public getBlockIdentifiers(platform: string, network: string, options?: any) {
        return BlocksApiFp(this.configuration).getBlockIdentifiers(platform, network, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NFTApi - axios parameter creator
 * @export
 */
export const NFTApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} protocol Coin platform handle
         * @param {string} network Which network to target
         * @param {string} id Mapped to URL query parameter \&#39;uuid\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerGetCollection: async (protocol: string, network: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'protocol' is not null or undefined
            assertParamExists('explorerGetCollection', 'protocol', protocol)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('explorerGetCollection', 'network', network)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('explorerGetCollection', 'id', id)
            const localVarPath = `/nft/{protocol}/{network}/collection/{id}`
                .replace(`{${"protocol"}}`, encodeURIComponent(String(protocol)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} protocol Coin platform handle
         * @param {string} network Which network to target
         * @param {string} [walletAddress] Mapped to URL query parameter &#x60;wallet_address&#x60;
         * @param {string} [contractAddress] Mapped to URL query parameter &#x60;contract_address&#x60;
         * @param {number} [tokenIdValue] The int64 value.
         * @param {string} [collectionName] Mapped to URL query parameter &#x60;collection_name&#x60;
         * @param {string} [sortBy] One of: name, token_id, mint_date
         * @param {string} [order] Mapped to URL query parameter &#x60;order&#x60; One of: asc, desc
         * @param {number} [pageSize] Mapped to URL query parameter &#x60;page_size&#x60;
         * @param {string} [pageToken] Mapped to URL query parameter &#x60;page_token&#x60; base64 encoded cursor
         * @param {Array<string>} [attributes] Mapped to URL query parameter &#x60;attributes&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerListAssets: async (protocol: string, network: string, walletAddress?: string, contractAddress?: string, tokenIdValue?: number, collectionName?: string, sortBy?: string, order?: string, pageSize?: number, pageToken?: string, attributes?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'protocol' is not null or undefined
            assertParamExists('explorerListAssets', 'protocol', protocol)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('explorerListAssets', 'network', network)
            const localVarPath = `/nft/{protocol}/{network}/assets`
                .replace(`{${"protocol"}}`, encodeURIComponent(String(protocol)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (walletAddress !== undefined) {
                localVarQueryParameter['wallet_address'] = walletAddress;
            }

            if (contractAddress !== undefined) {
                localVarQueryParameter['contract_address'] = contractAddress;
            }

            if (tokenIdValue !== undefined) {
                localVarQueryParameter['token_id.value'] = tokenIdValue;
            }

            if (collectionName !== undefined) {
                localVarQueryParameter['collection_name'] = collectionName;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }

            if (attributes) {
                localVarQueryParameter['attributes'] = attributes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} protocol Coin platform handle
         * @param {string} network Which network to target
         * @param {Array<string>} [contractAddress] Mapped to URL query parameter \&#39;contract_address\&#39;
         * @param {Array<string>} [collectionName] Mapped to URL query parameter \&#39;collection_name\&#39;
         * @param {string} [sortBy] Sort by one of: name
         * @param {string} [order] Mapped to URL query parameter &#x60;order&#x60; One of: asc, desc
         * @param {number} [pageSize] Mapped to URL query parameter &#x60;page_size&#x60;
         * @param {string} [pageToken] Mapped to URL query parameter &#x60;page_token&#x60; base64 encoded cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerListCollections: async (protocol: string, network: string, contractAddress?: Array<string>, collectionName?: Array<string>, sortBy?: string, order?: string, pageSize?: number, pageToken?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'protocol' is not null or undefined
            assertParamExists('explorerListCollections', 'protocol', protocol)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('explorerListCollections', 'network', network)
            const localVarPath = `/nft/{protocol}/{network}/collections`
                .replace(`{${"protocol"}}`, encodeURIComponent(String(protocol)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (contractAddress) {
                localVarQueryParameter['contractAddress'] = contractAddress;
            }

            if (collectionName) {
                localVarQueryParameter['collectionName'] = collectionName;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} protocol Coin platform handle
         * @param {string} network Which network to target
         * @param {string} [contractAddress] mapped to URL query parameter \&#39;contract_address\&#39;
         * @param {string} [walletAddress] mapped to URL query parameter \&#39;wallet_address\&#39;
         * @param {number} [tokenId] mapped to URL query parameter \&#39;token_id\&#39;
         * @param {string} [eventType] mapped to URL query parameter \&#39;event_type\&#39;
         * @param {string} [sortBy] Sort by one of: timestamp
         * @param {string} [order] Mapped to URL query parameter &#x60;order&#x60; One of: asc, desc
         * @param {number} [pageSize] Mapped to URL query parameter &#x60;page_size&#x60;
         * @param {string} [pageToken] Mapped to URL query parameter &#x60;page_token&#x60; base64 encoded cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerListEvents: async (protocol: string, network: string, contractAddress?: string, walletAddress?: string, tokenId?: number, eventType?: string, sortBy?: string, order?: string, pageSize?: number, pageToken?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'protocol' is not null or undefined
            assertParamExists('explorerListEvents', 'protocol', protocol)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('explorerListEvents', 'network', network)
            const localVarPath = `/nft/{protocol}/{network}/events`
                .replace(`{${"protocol"}}`, encodeURIComponent(String(protocol)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (contractAddress !== undefined) {
                localVarQueryParameter['contract_address'] = contractAddress;
            }

            if (walletAddress !== undefined) {
                localVarQueryParameter['wallet_address'] = walletAddress;
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['token_id'] = tokenId;
            }

            if (eventType !== undefined) {
                localVarQueryParameter['event_type'] = eventType;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NFTApi - functional programming interface
 * @export
 */
export const NFTApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NFTApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} protocol Coin platform handle
         * @param {string} network Which network to target
         * @param {string} id Mapped to URL query parameter \&#39;uuid\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async explorerGetCollection(protocol: string, network: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.explorerGetCollection(protocol, network, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} protocol Coin platform handle
         * @param {string} network Which network to target
         * @param {string} [walletAddress] Mapped to URL query parameter &#x60;wallet_address&#x60;
         * @param {string} [contractAddress] Mapped to URL query parameter &#x60;contract_address&#x60;
         * @param {number} [tokenIdValue] The int64 value.
         * @param {string} [collectionName] Mapped to URL query parameter &#x60;collection_name&#x60;
         * @param {string} [sortBy] One of: name, token_id, mint_date
         * @param {string} [order] Mapped to URL query parameter &#x60;order&#x60; One of: asc, desc
         * @param {number} [pageSize] Mapped to URL query parameter &#x60;page_size&#x60;
         * @param {string} [pageToken] Mapped to URL query parameter &#x60;page_token&#x60; base64 encoded cursor
         * @param {Array<string>} [attributes] Mapped to URL query parameter &#x60;attributes&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async explorerListAssets(protocol: string, network: string, walletAddress?: string, contractAddress?: string, tokenIdValue?: number, collectionName?: string, sortBy?: string, order?: string, pageSize?: number, pageToken?: string, attributes?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAssetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.explorerListAssets(protocol, network, walletAddress, contractAddress, tokenIdValue, collectionName, sortBy, order, pageSize, pageToken, attributes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} protocol Coin platform handle
         * @param {string} network Which network to target
         * @param {Array<string>} [contractAddress] Mapped to URL query parameter \&#39;contract_address\&#39;
         * @param {Array<string>} [collectionName] Mapped to URL query parameter \&#39;collection_name\&#39;
         * @param {string} [sortBy] Sort by one of: name
         * @param {string} [order] Mapped to URL query parameter &#x60;order&#x60; One of: asc, desc
         * @param {number} [pageSize] Mapped to URL query parameter &#x60;page_size&#x60;
         * @param {string} [pageToken] Mapped to URL query parameter &#x60;page_token&#x60; base64 encoded cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async explorerListCollections(protocol: string, network: string, contractAddress?: Array<string>, collectionName?: Array<string>, sortBy?: string, order?: string, pageSize?: number, pageToken?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.explorerListCollections(protocol, network, contractAddress, collectionName, sortBy, order, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} protocol Coin platform handle
         * @param {string} network Which network to target
         * @param {string} [contractAddress] mapped to URL query parameter \&#39;contract_address\&#39;
         * @param {string} [walletAddress] mapped to URL query parameter \&#39;wallet_address\&#39;
         * @param {number} [tokenId] mapped to URL query parameter \&#39;token_id\&#39;
         * @param {string} [eventType] mapped to URL query parameter \&#39;event_type\&#39;
         * @param {string} [sortBy] Sort by one of: timestamp
         * @param {string} [order] Mapped to URL query parameter &#x60;order&#x60; One of: asc, desc
         * @param {number} [pageSize] Mapped to URL query parameter &#x60;page_size&#x60;
         * @param {string} [pageToken] Mapped to URL query parameter &#x60;page_token&#x60; base64 encoded cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async explorerListEvents(protocol: string, network: string, contractAddress?: string, walletAddress?: string, tokenId?: number, eventType?: string, sortBy?: string, order?: string, pageSize?: number, pageToken?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.explorerListEvents(protocol, network, contractAddress, walletAddress, tokenId, eventType, sortBy, order, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NFTApi - factory interface
 * @export
 */
export const NFTApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NFTApiFp(configuration)
    return {
        /**
         * 
         * @param {string} protocol Coin platform handle
         * @param {string} network Which network to target
         * @param {string} id Mapped to URL query parameter \&#39;uuid\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerGetCollection(protocol: string, network: string, id: string, options?: any): AxiosPromise<GetCollectionResponse> {
            return localVarFp.explorerGetCollection(protocol, network, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} protocol Coin platform handle
         * @param {string} network Which network to target
         * @param {string} [walletAddress] Mapped to URL query parameter &#x60;wallet_address&#x60;
         * @param {string} [contractAddress] Mapped to URL query parameter &#x60;contract_address&#x60;
         * @param {number} [tokenIdValue] The int64 value.
         * @param {string} [collectionName] Mapped to URL query parameter &#x60;collection_name&#x60;
         * @param {string} [sortBy] One of: name, token_id, mint_date
         * @param {string} [order] Mapped to URL query parameter &#x60;order&#x60; One of: asc, desc
         * @param {number} [pageSize] Mapped to URL query parameter &#x60;page_size&#x60;
         * @param {string} [pageToken] Mapped to URL query parameter &#x60;page_token&#x60; base64 encoded cursor
         * @param {Array<string>} [attributes] Mapped to URL query parameter &#x60;attributes&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerListAssets(protocol: string, network: string, walletAddress?: string, contractAddress?: string, tokenIdValue?: number, collectionName?: string, sortBy?: string, order?: string, pageSize?: number, pageToken?: string, attributes?: Array<string>, options?: any): AxiosPromise<ListAssetsResponse> {
            return localVarFp.explorerListAssets(protocol, network, walletAddress, contractAddress, tokenIdValue, collectionName, sortBy, order, pageSize, pageToken, attributes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} protocol Coin platform handle
         * @param {string} network Which network to target
         * @param {Array<string>} [contractAddress] Mapped to URL query parameter \&#39;contract_address\&#39;
         * @param {Array<string>} [collectionName] Mapped to URL query parameter \&#39;collection_name\&#39;
         * @param {string} [sortBy] Sort by one of: name
         * @param {string} [order] Mapped to URL query parameter &#x60;order&#x60; One of: asc, desc
         * @param {number} [pageSize] Mapped to URL query parameter &#x60;page_size&#x60;
         * @param {string} [pageToken] Mapped to URL query parameter &#x60;page_token&#x60; base64 encoded cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerListCollections(protocol: string, network: string, contractAddress?: Array<string>, collectionName?: Array<string>, sortBy?: string, order?: string, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListCollectionResponse> {
            return localVarFp.explorerListCollections(protocol, network, contractAddress, collectionName, sortBy, order, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} protocol Coin platform handle
         * @param {string} network Which network to target
         * @param {string} [contractAddress] mapped to URL query parameter \&#39;contract_address\&#39;
         * @param {string} [walletAddress] mapped to URL query parameter \&#39;wallet_address\&#39;
         * @param {number} [tokenId] mapped to URL query parameter \&#39;token_id\&#39;
         * @param {string} [eventType] mapped to URL query parameter \&#39;event_type\&#39;
         * @param {string} [sortBy] Sort by one of: timestamp
         * @param {string} [order] Mapped to URL query parameter &#x60;order&#x60; One of: asc, desc
         * @param {number} [pageSize] Mapped to URL query parameter &#x60;page_size&#x60;
         * @param {string} [pageToken] Mapped to URL query parameter &#x60;page_token&#x60; base64 encoded cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerListEvents(protocol: string, network: string, contractAddress?: string, walletAddress?: string, tokenId?: number, eventType?: string, sortBy?: string, order?: string, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListEventResponse> {
            return localVarFp.explorerListEvents(protocol, network, contractAddress, walletAddress, tokenId, eventType, sortBy, order, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NFTApi - object-oriented interface
 * @export
 * @class NFTApi
 * @extends {BaseAPI}
 */
export class NFTApi extends BaseAPI {
    /**
     * 
     * @param {string} protocol Coin platform handle
     * @param {string} network Which network to target
     * @param {string} id Mapped to URL query parameter \&#39;uuid\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTApi
     */
    public explorerGetCollection(protocol: string, network: string, id: string, options?: any) {
        return NFTApiFp(this.configuration).explorerGetCollection(protocol, network, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} protocol Coin platform handle
     * @param {string} network Which network to target
     * @param {string} [walletAddress] Mapped to URL query parameter &#x60;wallet_address&#x60;
     * @param {string} [contractAddress] Mapped to URL query parameter &#x60;contract_address&#x60;
     * @param {number} [tokenIdValue] The int64 value.
     * @param {string} [collectionName] Mapped to URL query parameter &#x60;collection_name&#x60;
     * @param {string} [sortBy] One of: name, token_id, mint_date
     * @param {string} [order] Mapped to URL query parameter &#x60;order&#x60; One of: asc, desc
     * @param {number} [pageSize] Mapped to URL query parameter &#x60;page_size&#x60;
     * @param {string} [pageToken] Mapped to URL query parameter &#x60;page_token&#x60; base64 encoded cursor
     * @param {Array<string>} [attributes] Mapped to URL query parameter &#x60;attributes&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTApi
     */
    public explorerListAssets(protocol: string, network: string, walletAddress?: string, contractAddress?: string, tokenIdValue?: number, collectionName?: string, sortBy?: string, order?: string, pageSize?: number, pageToken?: string, attributes?: Array<string>, options?: any) {
        return NFTApiFp(this.configuration).explorerListAssets(protocol, network, walletAddress, contractAddress, tokenIdValue, collectionName, sortBy, order, pageSize, pageToken, attributes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} protocol Coin platform handle
     * @param {string} network Which network to target
     * @param {Array<string>} [contractAddress] Mapped to URL query parameter \&#39;contract_address\&#39;
     * @param {Array<string>} [collectionName] Mapped to URL query parameter \&#39;collection_name\&#39;
     * @param {string} [sortBy] Sort by one of: name
     * @param {string} [order] Mapped to URL query parameter &#x60;order&#x60; One of: asc, desc
     * @param {number} [pageSize] Mapped to URL query parameter &#x60;page_size&#x60;
     * @param {string} [pageToken] Mapped to URL query parameter &#x60;page_token&#x60; base64 encoded cursor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTApi
     */
    public explorerListCollections(protocol: string, network: string, contractAddress?: Array<string>, collectionName?: Array<string>, sortBy?: string, order?: string, pageSize?: number, pageToken?: string, options?: any) {
        return NFTApiFp(this.configuration).explorerListCollections(protocol, network, contractAddress, collectionName, sortBy, order, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} protocol Coin platform handle
     * @param {string} network Which network to target
     * @param {string} [contractAddress] mapped to URL query parameter \&#39;contract_address\&#39;
     * @param {string} [walletAddress] mapped to URL query parameter \&#39;wallet_address\&#39;
     * @param {number} [tokenId] mapped to URL query parameter \&#39;token_id\&#39;
     * @param {string} [eventType] mapped to URL query parameter \&#39;event_type\&#39;
     * @param {string} [sortBy] Sort by one of: timestamp
     * @param {string} [order] Mapped to URL query parameter &#x60;order&#x60; One of: asc, desc
     * @param {number} [pageSize] Mapped to URL query parameter &#x60;page_size&#x60;
     * @param {string} [pageToken] Mapped to URL query parameter &#x60;page_token&#x60; base64 encoded cursor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTApi
     */
    public explorerListEvents(protocol: string, network: string, contractAddress?: string, walletAddress?: string, tokenId?: number, eventType?: string, sortBy?: string, order?: string, pageSize?: number, pageToken?: string, options?: any) {
        return NFTApiFp(this.configuration).explorerListEvents(protocol, network, contractAddress, walletAddress, tokenId, eventType, sortBy, order, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlatformsApi - axios parameter creator
 * @export
 */
export const PlatformsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provides information about supported endpoints and generic platform information. 
         * @summary Platform Info
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatformEndpoints: async (platform: string, network: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getPlatformEndpoints', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getPlatformEndpoints', 'network', network)
            const localVarPath = `/{platform}/{network}/`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides a list of supported platforms and networks. 
         * @summary Platforms overview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatformsList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlatformsApi - functional programming interface
 * @export
 */
export const PlatformsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlatformsApiAxiosParamCreator(configuration)
    return {
        /**
         * Provides information about supported endpoints and generic platform information. 
         * @summary Platform Info
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlatformEndpoints(platform: string, network: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlatformDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlatformEndpoints(platform, network, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Provides a list of supported platforms and networks. 
         * @summary Platforms overview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlatformsList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlatformsOverview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlatformsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlatformsApi - factory interface
 * @export
 */
export const PlatformsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlatformsApiFp(configuration)
    return {
        /**
         * Provides information about supported endpoints and generic platform information. 
         * @summary Platform Info
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatformEndpoints(platform: string, network: string, options?: any): AxiosPromise<PlatformDetail> {
            return localVarFp.getPlatformEndpoints(platform, network, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides a list of supported platforms and networks. 
         * @summary Platforms overview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatformsList(options?: any): AxiosPromise<PlatformsOverview> {
            return localVarFp.getPlatformsList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlatformsApi - object-oriented interface
 * @export
 * @class PlatformsApi
 * @extends {BaseAPI}
 */
export class PlatformsApi extends BaseAPI {
    /**
     * Provides information about supported endpoints and generic platform information. 
     * @summary Platform Info
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlatformsApi
     */
    public getPlatformEndpoints(platform: string, network: string, options?: any) {
        return PlatformsApiFp(this.configuration).getPlatformEndpoints(platform, network, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides a list of supported platforms and networks. 
     * @summary Platforms overview
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlatformsApi
     */
    public getPlatformsList(options?: any) {
        return PlatformsApiFp(this.configuration).getPlatformsList(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SyncApi - axios parameter creator
 * @export
 */
export const SyncApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get current block ID
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentBlockID: async (platform: string, network: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('currentBlockID', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('currentBlockID', 'network', network)
            const localVarPath = `/{platform}/{network}/sync/block_id`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current block number
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentBlockNumber: async (platform: string, network: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('currentBlockNumber', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('currentBlockNumber', 'network', network)
            const localVarPath = `/{platform}/{network}/sync/block_number`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SyncApi - functional programming interface
 * @export
 */
export const SyncApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SyncApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get current block ID
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentBlockID(platform: string, network: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentBlockID(platform, network, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get current block number
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentBlockNumber(platform: string, network: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentBlockNumber(platform, network, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SyncApi - factory interface
 * @export
 */
export const SyncApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SyncApiFp(configuration)
    return {
        /**
         * 
         * @summary Get current block ID
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentBlockID(platform: string, network: string, options?: any): AxiosPromise<string> {
            return localVarFp.currentBlockID(platform, network, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current block number
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentBlockNumber(platform: string, network: string, options?: any): AxiosPromise<number> {
            return localVarFp.currentBlockNumber(platform, network, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SyncApi - object-oriented interface
 * @export
 * @class SyncApi
 * @extends {BaseAPI}
 */
export class SyncApi extends BaseAPI {
    /**
     * 
     * @summary Get current block ID
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncApi
     */
    public currentBlockID(platform: string, network: string, options?: any) {
        return SyncApiFp(this.configuration).currentBlockID(platform, network, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current block number
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncApi
     */
    public currentBlockNumber(platform: string, network: string, options?: any) {
        return SyncApiFp(this.configuration).currentBlockNumber(platform, network, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a fee estimation in decimals from the ubiquity fee estimation service. Currently supported for Bitcoin and Ethereum. Endpoint will return 3 fee estimations fast, medium and slow 
         * @summary Get fee estimate
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feeEstimate: async (platform: string, network: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('feeEstimate', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('feeEstimate', 'network', network)
            const localVarPath = `/{platform}/{network}/tx/estimate_fee`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transaction By Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} id Transaction ID/Hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTx: async (platform: string, network: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getTx', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getTx', 'network', network)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTx', 'id', id)
            const localVarPath = `/{platform}/{network}/tx/{id}`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transaction output by hash and index
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} id Transaction ID/Hash
         * @param {number} index Transaction output index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxByHashAndIndex: async (platform: string, network: string, id: string, index: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getTxByHashAndIndex', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getTxByHashAndIndex', 'network', network)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTxByHashAndIndex', 'id', id)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('getTxByHashAndIndex', 'index', index)
            const localVarPath = `/{platform}/{network}/tx/{id}/{index}`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transaction confirmations By Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} id Transaction ID/Hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxConfirmations: async (platform: string, network: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getTxConfirmations', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getTxConfirmations', 'network', network)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTxConfirmations', 'id', id)
            const localVarPath = `/{platform}/{network}/tx/{id}/confirmations`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets transactions from oldest to newest. This call uses pagination. 
         * @summary Latest transactions of a protocol
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {'desc' | 'asc'} [order] Pagination order
         * @param {string} [continuation] Continuation token from earlier response
         * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxs: async (platform: string, network: string, order?: 'desc' | 'asc', continuation?: string, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getTxs', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getTxs', 'network', network)
            const localVarPath = `/{platform}/{network}/txs`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (continuation !== undefined) {
                localVarQueryParameter['continuation'] = continuation;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit a signed transaction to the network.  **Note**: A successful transaction may still be rejected on chain or not processed due to a too low fee. You can monitor successful transactions through Ubiquity websockets. 
         * @summary Submit a signed transaction
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {SignedTx} signedTx 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txSend: async (platform: string, network: string, signedTx: SignedTx, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('txSend', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('txSend', 'network', network)
            // verify required parameter 'signedTx' is not null or undefined
            assertParamExists('txSend', 'signedTx', signedTx)
            const localVarPath = `/{platform}/{network}/tx/send`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signedTx, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a fee estimation in decimals from the ubiquity fee estimation service. Currently supported for Bitcoin and Ethereum. Endpoint will return 3 fee estimations fast, medium and slow 
         * @summary Get fee estimate
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feeEstimate(platform: string, network: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeeEstimate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feeEstimate(platform, network, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Transaction By Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} id Transaction ID/Hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTx(platform: string, network: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTx(platform, network, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Transaction output by hash and index
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} id Transaction ID/Hash
         * @param {number} index Transaction output index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxByHashAndIndex(platform: string, network: string, id: string, index: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTxByHashAndIndex(platform, network, id, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Transaction confirmations By Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} id Transaction ID/Hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxConfirmations(platform: string, network: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxConfirmation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTxConfirmations(platform, network, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets transactions from oldest to newest. This call uses pagination. 
         * @summary Latest transactions of a protocol
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {'desc' | 'asc'} [order] Pagination order
         * @param {string} [continuation] Continuation token from earlier response
         * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxs(platform: string, network: string, order?: 'desc' | 'asc', continuation?: string, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTxs(platform, network, order, continuation, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Submit a signed transaction to the network.  **Note**: A successful transaction may still be rejected on chain or not processed due to a too low fee. You can monitor successful transactions through Ubiquity websockets. 
         * @summary Submit a signed transaction
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {SignedTx} signedTx 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async txSend(platform: string, network: string, signedTx: SignedTx, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxReceipt>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.txSend(platform, network, signedTx, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * Get a fee estimation in decimals from the ubiquity fee estimation service. Currently supported for Bitcoin and Ethereum. Endpoint will return 3 fee estimations fast, medium and slow 
         * @summary Get fee estimate
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feeEstimate(platform: string, network: string, options?: any): AxiosPromise<FeeEstimate> {
            return localVarFp.feeEstimate(platform, network, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transaction By Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} id Transaction ID/Hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTx(platform: string, network: string, id: string, options?: any): AxiosPromise<Tx> {
            return localVarFp.getTx(platform, network, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transaction output by hash and index
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} id Transaction ID/Hash
         * @param {number} index Transaction output index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxByHashAndIndex(platform: string, network: string, id: string, index: number, options?: any): AxiosPromise<TxOutput> {
            return localVarFp.getTxByHashAndIndex(platform, network, id, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transaction confirmations By Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} id Transaction ID/Hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxConfirmations(platform: string, network: string, id: string, options?: any): AxiosPromise<TxConfirmation> {
            return localVarFp.getTxConfirmations(platform, network, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets transactions from oldest to newest. This call uses pagination. 
         * @summary Latest transactions of a protocol
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {'desc' | 'asc'} [order] Pagination order
         * @param {string} [continuation] Continuation token from earlier response
         * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxs(platform: string, network: string, order?: 'desc' | 'asc', continuation?: string, limit?: number, options?: any): AxiosPromise<TxPage> {
            return localVarFp.getTxs(platform, network, order, continuation, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit a signed transaction to the network.  **Note**: A successful transaction may still be rejected on chain or not processed due to a too low fee. You can monitor successful transactions through Ubiquity websockets. 
         * @summary Submit a signed transaction
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {SignedTx} signedTx 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txSend(platform: string, network: string, signedTx: SignedTx, options?: any): AxiosPromise<TxReceipt> {
            return localVarFp.txSend(platform, network, signedTx, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * Get a fee estimation in decimals from the ubiquity fee estimation service. Currently supported for Bitcoin and Ethereum. Endpoint will return 3 fee estimations fast, medium and slow 
     * @summary Get fee estimate
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public feeEstimate(platform: string, network: string, options?: any) {
        return TransactionsApiFp(this.configuration).feeEstimate(platform, network, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Transaction By Hash
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {string} id Transaction ID/Hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTx(platform: string, network: string, id: string, options?: any) {
        return TransactionsApiFp(this.configuration).getTx(platform, network, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Transaction output by hash and index
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {string} id Transaction ID/Hash
     * @param {number} index Transaction output index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTxByHashAndIndex(platform: string, network: string, id: string, index: number, options?: any) {
        return TransactionsApiFp(this.configuration).getTxByHashAndIndex(platform, network, id, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Transaction confirmations By Hash
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {string} id Transaction ID/Hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTxConfirmations(platform: string, network: string, id: string, options?: any) {
        return TransactionsApiFp(this.configuration).getTxConfirmations(platform, network, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets transactions from oldest to newest. This call uses pagination. 
     * @summary Latest transactions of a protocol
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {'desc' | 'asc'} [order] Pagination order
     * @param {string} [continuation] Continuation token from earlier response
     * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTxs(platform: string, network: string, order?: 'desc' | 'asc', continuation?: string, limit?: number, options?: any) {
        return TransactionsApiFp(this.configuration).getTxs(platform, network, order, continuation, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit a signed transaction to the network.  **Note**: A successful transaction may still be rejected on chain or not processed due to a too low fee. You can monitor successful transactions through Ubiquity websockets. 
     * @summary Submit a signed transaction
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {SignedTx} signedTx 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public txSend(platform: string, network: string, signedTx: SignedTx, options?: any) {
        return TransactionsApiFp(this.configuration).txSend(platform, network, signedTx, options).then((request) => request(this.axios, this.basePath));
    }
}


